report <- function(x) UseMethod("report")

#' Title
#'
#' @param x a radf object.
#' @param y a cv oject.
#'
#' @export
report <- function(x, y){

  radf_check(x)
  cv_check(y)
  minw_check(x, y)

  ret <- list()
  if (method(y) == "Wild Bootstrap") {
    for (i in seq_along(col_names(x))) {
      df1 <- c(x$adf[i], y$adf_cv[i, ])
      df2 <- c(x$sadf[i], y$sadf_cv[i, ])
      df3 <- c(x$gsadf[i], y$gsadf_cv[i, ])
      df <- data.frame( rbind(df1,df2,df3), row.names = c("ADF","SADF","GSADF"))
      colnames(df) <- c("t-stat", "90%", "95%", "95%")
      ret[[i]] <- df
    }
  }else if (method(y) == "Monte Carlo") {
    for (i in seq_along(col_names(x))) {
      df1 <- c(x$adf[i], y$adf_cv)
      df2 <- c(x$sadf[i], y$sadf_cv)
      df3 <- c(x$gsadf[i], y$gsadf_cv)
      df <- data.frame( rbind(df1,df2,df3), row.names = c("ADF","SADF","GSADF"))
      colnames(df) <- c("tstat", "90%", "95%", "95%")
      ret[[i]] <- df
    }
  }

  attr(ret, "minw") <- minw(y)
  attr(ret, "lag") <- lagr(x)
  attr(ret, "method") <- method(y)

  names(ret) <- col_names(x)
  class(ret) <- append(class(ret), "report")
  ret
}


#' @export
print.report <- function(x, ...) {
  cat('\n', "Recursive Unit Root Testing Summary", '\n',
      "---------------------------------------------",'\n',
      "H0:", "Unit root ", '\n',
      "H1:", "Explosive root", "\n",
      "---------------------------------------------\n",
      "Critical values are generated by:" , method(x),'\n',
      "Number of",
      if (method(x) == "Monte Carlo") "iterations:" else "bootstraps:"
        , iter(x),'\n',
      "Minimum window is set to:", minw(x),'\n',
      "Lag is set to:", lagr(x),'\n',
      "---------------------------------------------")
  for (i in seq_along(x)) {
    cat('\n', names(x)[i], '\n')
    print(x[[i]])
  }
}


# diagnostics -------------------------------------------------------------



diagnostics <- function(x) UseMethod("diagnostics")

#' @inheritParams report
#' @param option check which methodology to use
#' @describeIn report mpla mpla
#' @import dplyr
#' @export
diagnostics <- function(x,y, option = c("gsadf", "sadf")) {

  radf_check(x)
  cv_check(y)
  minw_check(x, y)
  option <- match.arg(option)


  if (option == "gsadf") {
    tstat <- x$gsadf
    if (method(y) == "Monte Carlo") {
      cv1 <- y$gsadf_cv[1]
      cv2 <- y$gsadf_cv[2]
      cv3 <- y$gsadf_cv[3]
    }else{
      cv1 <- y$gsadf_cv[, 1]
      cv2 <- y$gsadf_cv[, 2]
      cv3 <- y$gsadf_cv[, 3]
    }
  }else{
    tstat <- x$sadf
    if (method(y) == "Monte Carlo") {
      cv1 <- y$sadf_cv[1]
      cv2 <- y$sadf_cv[2]
      cv3 <- y$sadf_cv[3]
    }else{
      cv1 <- y$sadf_cv[, 1]
      cv2 <- y$sadf_cv[, 2]
      cv3 <- y$sadf_cv[, 3]
    }
  }

  sig <- case_when(
    tstat < cv1 ~ "Reject",
    tstat >= cv1 & tstat < cv2 ~ "90%",
    tstat >= cv2 & tstat < cv3 ~ "90%",
    tstat >= cv3 ~ "99%"
  )


  if (all(sig == "Reject")) {
    stop("Cannot reject H0, do not proceed for date stamping or plotting", call. = FALSE)
  }

  cond <- sig == "95%" | sig == "99%"
  proceed <- col_names(x)[cond]

  attr(proceed, "significance") <- sig
  class(proceed) <- "diagnostics"
  attr(proceed, "col_names") <- col_names(x)

  proceed
}


#' @export
print.diagnostics <- function(x, ...) {
  cat('\n',
      "Diagnostics:",
      "\n---------------------------------------------")
  for (i in seq_along(attr(x,"col_names"))) {
    cat("\n", attr(x, "col_names")[i],":", sep = "")
    if (attr(x, "significance")[i] == "Reject") {
      cat("\n", "Cannot reject H0!")
    }else{
      cat("\n","Rejects H0 for significance level", attr(x, "significance")[i])
    }
  }
  if (is.null(x)) {
    cat("\n---------------------------------------------",
        "\nYou cannot proceed for date stamping!")
  }else{
    cat("\n---------------------------------------------",
        "\nProcced for date stampting and plotting for variable(s)", deparse(as.vector(x)))
  }
}



# datestamp ---------------------------------------------------------------

#' Date stamping the bubble period(s)
#'
#' \code{datestamp} computes the origination, termination and duration of the bubble episode(s) detected by
#' \code{radf}. Setting \code{min.duration} allows temporary spikes above the critical value sequence to be removed.
#'
#' @inheritParams report
#' @param option whether to plot badf-tstat with the adf-cv or bsadf-tsat with the badf-cv.
#' The default value is "badf".
#' @param min_duration the minimum duration of an explosive period for it to be reported. Default is 0.
#'
#' @return Returns a list of values for each explosive sub-period, giving the origin and termination dates as well as the number of periods explosive behaviour lasts.
#' @references Add reference to Phillips paper here.
#'
#' @importFrom rlang sym
#' @import dplyr
#' @export
#'
datestamp <- function(x, y, option = c("gsadf","sadf"), min_duration = 0) {

  radf_check(x)
  cv_check(y)
  minw_check(x, y)
  is.nonnegeative.int(min_duration)

  option <- match.arg(option)

  if (method(y) == "Wild Bootstrap" & option == "sadf") {
    stop("  Explosive periods with Wild Bootstraped critical valuesapply only for the option 'gsadf' ",
         call. = FALSE)
  }

  reps <- diagnostics(x, y, option) %>% match(col_names(x))
  dating <- index(x)[-c(1:(minw(x) + 1 + lagr(x)))]

  ds <- vector("list", length(reps))
  j <- 1
  for (i in reps) {
    if (method(y) == "Monte Carlo") {
      if (option == "gsadf") {
        ds[[j]] <- which(x$bsadf[,i] > y$badf_cv[,2]) + minw(x) + 1
      }else if (option == "sadf") {
        ds[[j]] <- which(x$badf[, i] > y$adf_cv[2]) + minw(x) + 1
      }
    }else if (method(y) == "Wild Bootstrap") {
      if (option == "gsadf") {
        ds[[j]] <- which(x$bsadf[,i] > y$badf_cv[, 2, i]) + minw(x) + 1
      }else if (option == "sadf") {
        ds[[j]] <- which(x$badf[, i] > rep(y$adf_cv[i, 2], NROW(x$badf))) + minw(x) + 1
      }
    }
    j <- j + 1
  }
  ds_stamp <- lapply(ds, function(z) z %>% stamp() %>%
                       filter(!!sym("Duration") >= min_duration) %>% as.matrix())

  index_corrected <- lapply(ds_stamp, function(t) data.frame(
    "Start" = index(x)[t[, 1]],
    "End" = index(x)[t[, 2]],
    "Duration" = t[, 3], row.names = NULL
  ))

  min_reject <- lapply(ds_stamp, is.data.frame0) %>% unlist()
  res <- index_corrected[!min_reject]

  if (length(res) == 0) {
    stop("Argument 'min_duration' excludes all the explosive periods", call. = FALSE)
  }

  names(res) <- col_names(x)[reps][!min_reject]
  res
}

is.data.frame0 <- function(df) {
  is.data.frame(df) && nrow(df) == 0
}

stamp <- function(ds) {
  start <- ds[c(TRUE, diff(ds) != 1)]
  end   <- ds[c(diff(ds) != 1, TRUE)]
  end[end - start == 0] <- end[end - start == 0] + 1
  duration <- end - start + 1
  foo <- data.frame("Start" = start, "End" = end, "Duration" = duration)
  foo
}

repn <- function(x) {
  ln <- lapply(x, function(x) NROW(x)) %>% unlist()
  nm <- names(x)
  rep(nm, ln)
}

# Plotting ----------------------------------------------------------------


#' Plotting
#'
#' @inheritParams datestamp
#' @param breaks_x plotting option
#' @param format_date a cv object
#' @param breaks_y plotting option
#' @param plot_type for multivariate radf objects, "multiple" plots the series on multiple
#' plots and "single" superimposes them on a single plot datestamping only the period of
#' explosiveness. Default is "multiple".
#' @param ... additional graphical arguments passed on to methods. Currently not used
#'
#' @return a list of ggplot objects
#' @export
#'
#' @import ggplot2
#' @import dplyr
#' @import tidyr
#' @importFrom utils head tail
#' @importFrom graphics plot
#' @importFrom magrittr set_colnames
#' @importFrom rlang sym
#' @importFrom purrr map
#'
plot.radf <- function(x, y,
                      option = c("gsadf", "sadf"),
                      min_duration = 0,
                      breaks_x ,
                      format_date = "%m-%Y",
                      breaks_y ,
                      plot_type = c("multiple", "single"), ...) {

  cv_check(y)
  minw_check(x, y)
  option <- match.arg(option)
  plot_type <- match.arg(plot_type)



  choice <- diagnostics(x, y, option)
  reps <- match(choice, col_names(x))
  dating <- index(x)[-c(1:(minw(x) + 1 + lagr(x)))]
  shade <- datestamp(x, y, option = option, min_duration = min_duration)

  if (missing(breaks_x)) { #need to work on a transformation formula
    if (class(index(x)) == "Date") {
      breaks_x = "3 months"
    }else{
      breaks_x = 10
    }
  }
  ## Consider option = "sadf" with Wb does not make any difference
  # for diagnostics and datestmap as well

  if (is.null(reps)) {
    stop("Plotting is only for the series that reject the Null Hypothesis", call. = FALSE)
  }
  if (!missing(breaks_y) & plot_type == "single") {
    warning("Argument 'breaks_y' is redundant plot_type is set to 'single'", call. = FALSE)
  }
  if ((length(choice) == 1 || length(shade) == 1) & plot_type == "single" ) {
    warning("Argument 'plot_type' should be set to 'multiple' when there is only one series to plot",
            call. = FALSE)
  }

  if (plot_type == "multiple") {

    dat <- vector("list", length(choice))

    for (i in reps) {
      if (option == "gsadf") {

        tstat_dat = x$bsadf[, i]

        if (method(y) == "Monte Carlo") {
          if (lagr(x) == 0) {
            cv_dat = y$badf_cv[,2]
          }else{
            cv_dat =  head(y$badf_cv[, 2], -lagr(x), row.names = NULL)
          }
        } else if (method(y) == "Wild Bootstrap") {
          if (lagr(x) == 0) {
            cv_dat = y$badf_cv[, 2, i]
          }else{
            cv_dat =  head(y$badf_cv[, 2, i], -lagr(x), row.names = NULL)
          }
        }
      }else if (option == "sadf") {
        tstat_dat = x$badf[, i]
        if (method(y) == "Monte Carlo") {
          cv_dat = rep(y$adf_cv[2], NROW(x$badf) - lagr(x))
        } else if (method(y) == "Wild Bootstrap") {
          cv_dat =  rep(y$adf_cv[i, 2], NROW(x$badf) - lagr(x))
        }
      }

      dat[[i]] <- data.frame("dating" = dating,
                             "tstat" = tstat_dat,
                             "cv" = cv_dat)
    }

   if (missing(breaks_y)) breaks_y <- 1 #transform here as well

    h <- vector("list", length(choice))
    j <- 1
    for (i in reps)
      local({
        i <- i
        p <- ggplot(dat[[i]]) + geom_line(aes_string(x = "dating", y = "tstat"), size = 0.7, colour = "blue") +
          geom_line(aes_string(x = "dating", y = "cv"), colour = "red", size = 0.8, linetype = "dashed") +
          xlab("") + ylab("") + theme_bw() +
          theme(axis.line = element_line(colour = "black"), panel.grid.major = element_blank(),
                panel.grid.minor = element_blank(), panel.background = element_blank()) +
          ggtitle(choice[j]) +
          scale_y_continuous(breaks = seq(floor(min(dat[[i]]$tstat)), ceiling(max(dat[[i]]$tstat)), breaks_y)) +
          geom_rect(data = shade[[j]][1:2],
                    aes_string(xmin = "Start", xmax = "End", ymin = -Inf, ymax = +Inf),
                    fill = 'grey', alpha = 0.25) +
          {if (class(index(x)) == "Date") {
            scale_x_date(date_breaks = breaks_x, date_labels = format_date)
            }else{
              scale_x_continuous(breaks = seq(0, max(index(x)), breaks_x))
            }
          }

        h[[j]] <<- p
        j <<- j + 1

      })
  }else if (plot_type == "single") {

    total <- data.frame(
      "key" = shade %>% repn,
      "start" = shade %>% map(~ .x[1]) %>% unlist,
      "end" = shade %>% map(~ .x[2]) %>% unlist
    ) %>% mutate("start_date" = index(x)[!!sym("start")], "end_date" = index(x)[!!sym("end")]) %>%
      filter(!!sym("end") - !!sym("start") - 1 >= min_duration)

    h <- ggplot(total, aes_string(colour = "key")) +
      geom_segment(aes_string(x = "start_date", xend = "end_date", y = "key", yend = "key"), size = 7) +
      ylab("") + xlab("") + theme_bw() +
      theme(panel.grid.major.y = element_blank() ,legend.position = "none",
          plot.margin = margin(1,1,0,0,"cm"), axis.text.y = element_text(face = "bold",
                                                                         size = 8, hjust = 0))

    if (class(index(x)) == "Date") {
      h <- h + scale_x_date(date_breaks = breaks_x, date_labels = format_date,
                            limits = c(head(dating, 1), tail(index(x), 1)))
    }else{
      h <- h + scale_x_continuous(breaks = seq(0, max(index(x)), breaks_x),
                                  limits = c(minw(x), tail(index(x), 1)))
    }
  }

  if (length(h) == 1) {
    return(h[[1]])
  }else{
    return(h)
  }
}
