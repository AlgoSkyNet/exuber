report <- function(x) UseMethod("report")

#' Title
#'
#' @param x of class 'radf'.
#' @param y the output of mc_cv or wb_cv.
#'
#' @export
report <- function(x, y){

  if (!inherits(x, "radf")) stop("Argument 'x' should be of class 'radf'")
  if (is.list(y) & length(attributes(y)$method) == 0) stop("Arguement 'y' should be the result of 'mc_cv' or 'wb_cv'")
  if (attributes(x)$minw != attributes(y)$minw) {
    stop("The critical values should have the same minumum window with the t-statistics!")
  }
  ret <- list()
  if (attributes(y)$method == "Wild Bootstrap") {
    for (i in seq_along(attributes(x)$col_names)) {
      df1 <- c(x$adf[i], y$adf_cv[i, ])
      df2 <- c(x$sadf[i], y$sadf_cv[i, ])
      df3 <- c(x$gsadf[i], y$gsadf_cv[i, ])
      df <- data.frame( rbind(df1,df2,df3), row.names = c("ADF","SADF","GSADF"))
      colnames(df) <- c("t-stat", "90%", "95%", "95%")
      ret[[i]] <- df
    }
  }else if (attributes(y)$method == "Monte Carlo") {
    for (i in seq_along(attributes(x)$col_names)) {
      df1 <- c(x$adf[i], y$adf_cv)
      df2 <- c(x$sadf[i], y$sadf_cv)
      df3 <- c(x$gsadf[i], y$gsadf_cv)
      df <- data.frame( rbind(df1,df2,df3), row.names = c("ADF","SADF","GSADF"))
      colnames(df) <- c("tstat", "90%", "95%", "95%")
      ret[[i]] <- df
    }
  }

  attr(ret, "minw") <- attributes(y)$minw
  attr(ret, "lag") <- attributes(x)$lag
  attr(ret, "method") <- attributes(y)$method

  names(ret) <- attributes(x)$col_names
  class(ret) <- c("list","report")
  ret
}


#' @export
print.report <- function(x, ...) {
  cat('\n',"---------------------------------------------",'\n',
      "H0:", "Unit root ",'\n',
      "H1:", "Explosive root",
      "\n----------------------------------------------\n",
      "Critical values are generated by:" , attributes(x)$method,'\n',
      "Number of", if (attributes(x)$method == "Monte Carlo") "iterations:" else "bootstraps:"
        , attributes(x)$iter,'\n',
      "Minimum window is set to:", attributes(x)$minw,'\n',
      "Lag is set to:", attributes(x)$lag,'\n',
      "---------------------------------------------")
  for (i in seq_along(x)) {
    cat('\n', names(x)[i], '\n')
    print(x[[i]])
  }
}

diagnostics <- function(x) UseMethod("diagnostics")



#' @inheritParams report
#' @describeIn report mpla mpla
#' @export
diagnostics <- function(x, y){

  if (!inherits(x, "radf")) stop("Argument 'x' should be of class 'radf'")
  if (is.list(y) & length(attributes(y)$method) == 0)
    stop("Arguement 'y' should be the result of 'mc_cv' or 'wb_cv'")
  # stopifnot(is.logical(echo))

  nm <- attributes(x)$col_names
  proceed <- NULL
  sig <- NULL

  for (i in seq_along(nm)) {
    if (attributes(y)$method == "Monte Carlo") {
      if (x$gsadf[i] > y$gsadf_cv[1]) {
        if (x$gsadf[i] > y$gsadf_cv[2]) {
          if (x$gsadf[i] > y$gsadf_cv[3]) {
            proceed <- c(proceed, nm[i])
            sig <- append(sig, "99%")
          }else{
            proceed <- c(proceed, nm[i])
            sig <- append(sig, "95%")
          }
        }else{
          proceed <- c(proceed, nm[i])
          sig <- append(sig, "90%")
        }
      } else{
        sig <- append(sig, "Reject")
      }
    }else{
      if (x$gsadf[i] > y$gsadf_cv[i, 1]) {
        if (x$gsadf[i] > y$gsadf_cv[i, 2]) {
          if (x$gsadf[i] > y$gsadf_cv[i, 3]) {
            proceed <- c(proceed, nm[i])
            sig <- append(sig, "99%")
          }else{
            proceed <- c(proceed, nm[i])
            sig <- append(sig, "95%")
          }
        }else{
          proceed <- c(proceed, nm[i])
          sig <- append(sig, "90%%")
        }
      }else{
        sig <- append(sig, "Reject")
      }
    }
  }
  attr(proceed, "sig") <- sig
  class(proceed) <- "diagnostics"
  names(proceed) <- attributes(x)$col_names
  proceed
}

#' @export
print.diagnostics <- function(x, ...) {
    cat('\n',
        "Diagnostics:",
        "\n---------------------------------------------")
    for (i in seq_along(x)) {
      cat("\n", names(x)[i],":", sep = "")
      if (attributes(x)$sig[i] == "Reject") {
        cat("\n", "Cannot reject H0!")
      }else{
        cat("\n","Rejects H0 for significance level", attributes(x)$sig[i])
      }
    }
    if (is.null(x)) {
      cat("\n---------------------------------------------",
          "\nYou cannot proceed for date stamping!")
    }else{
      cat("\n---------------------------------------------",
          "\nProcced for date stampting and plotting for variable(s)", deparse(as.vector(x)))
    }
}

dummy.plot <- function(x, y, option){

  dummy.plot <- matrix(0, nrow = NROW(x$badf), ncol = length(attributes(x)$col_names))

  for (i in seq_along(attributes(x)$col_names)) {
    for (j in 1:(NROW(x$bsadf))) {
      if (option == "badf") {
        if (attributes(y)$method == "Monte Carlo") {
          if (x$bsadf[j, i] > y$badf_cv[j, 2]) dummy.plot[j, i] = 1
        }else if (attributes(y)$method == "Wild Bootstrap") {
          if (x$bsadf[j, i] > y$badf_cv[j, 2, i]) dummy.plot[j, i] = 1
        }
      }else if (option == "bsadf") {
        if (attributes(y)$method == "Monte Carlo") {
          if (x$bsadf[j, i] > y$bsadf_cv[j, 2]) dummy.plot[j, i] = 1
        }else if (attributes(y)$method == "Wild Bootstrap") {
          if (x$bsadf[j, i] > y$bsadf_cv[j, 2, i]) dummy.plot[j, i] = 1
        }
      }
    }
  }
  return(dummy.plot)
}

shade <- function(x){
  b <- matrix(0, 100, NCOL(x))
  e <- matrix(0, 100, NCOL(x))
  for (i in 1:NCOL(x)) {
    if (x[1, i] == 1) { #detect when series start with bubble
      b[,i] <- c(1, which(diff(x[, i]) == 1) + 1,
                 rep(NA, NROW(b) - length(which(diff(x[,i]) == 1)) - 1))
    }else{
      b[,i] <- c(which(diff(x[, i]) == 1) + 1,
                 rep(NA, NROW(b) - length(which(diff(x[,i]) == 1))))
    }
    if (x[NROW(x),i]) {
      e[,i] <- c( which(diff(x[, i]) == -1) + 1, NROW(x),
                  rep(NA, NROW(e) - length(which(diff(x[,i]) == -1)) - 1))
    }else{
      e[,i] <- c( which(diff(x[, i]) == -1) + 1,
                  rep(NA, NROW(e) - length(which(diff(x[, i]) == -1))))
    }
  }
  return( list(b = b, e = e))
}


#' Date stamping the bubble period(s)
#'
#' \code{datestamp} computes the origination, termination and duration of the bubble episode(s) detected by
#' \code{radf}. Setting \code{min.duration} allows temporary spikes above the critical value sequence to be removed.
#'
#' @inheritParams report
#' @param option the default value is "badf".
#' @param min_duration the minimum duration of an explosive period for it to be reported. Defaults to log(T).
#'
#' @return Returns a list of values for each explosive sub-period, giving the origin and termination dates as well as the number of periods explosive behaviour lasts.
#' @references Add reference to Phillips paper here.
#'
#' @importFrom tidyr %>% drop_na
#' @importFrom dplyr filter
#' @importFrom rlang sym
#' @export
#'
datestamp <- function(x, y, option = c("badf", "bsadf"),
                      min_duration = 0){

  if (!inherits(x, "radf")) stop("Argument 'x' should be of class 'radf'")
  if (is.list(y) & length(attributes(y)$method) == 0) stop("Argument 'y' should be the result of 'mc_cv'or 'wb_cv'")
  option <- match.arg(option)
  is.nonnegeative.int(min_duration)

  dating <- attributes(x)$date[-c(1:(attributes(x)$minw + 1 + attributes(x)$lag))]
  temp <- dummy.plot(x, y, option = option) %>% shade()
  iter <- diagnostics(x, y) %>% match(attributes(x)$col_names)

  rect_regions <- list();j <- 1
  for (i in iter) {
    rect_regions[[j]] <- data.frame("Peak" = dating[temp$b[, i]],
                        "Trough" = dating[temp$e[, i]],
                        "Duration" = temp$e[, i] - temp$b[, i]) %>%
      drop_na() %>% filter(!! sym("Duration") >= min_duration)
    j <- j + 1
  }
  names(rect_regions) <- attributes(x)$col_names[iter]
  return(rect_regions)
}

#' Plotting
#'
#' @inheritParams report
#' @param breaks_x plotting option
#' @param format_plot plotiing option
#' @param breaks_y plotting option
#' @param option choose bertwsadfad
#' @param plot_type type gannt if true
#' @param ... not used
#'
#' @return a list of ggplot
#' @export
#'
#' @import ggplot2
#' @import dplyr
#' @import tidyr
#' @importFrom utils head
#' @importFrom graphics plot
#' @importFrom magrittr set_colnames
#' @importFrom rlang sym
#'
plot.radf <- function(x, y,
                      option = c("badf", "bsadf"),
                      breaks_x ,
                      format_plot = "%m-%Y",
                      breaks_y ,
                      plot_type = c("multiple", "single"), ...) {

  option <- match.arg(option)
  plot_type <- match.arg(plot_type)
  if (!inherits(x, "radf")) stop("Argument 'x' should be of class 'radf'")
  if (is.list(y) & length(attributes(y)$method) == 0) stop("Argument 'y' should be the result of 'mc_cv' or 'wb_cv'")
  if (missing(breaks_x)) if (class(attributes(x)$date) == "Date") breaks_x = "3 months" else breaks_x = 10
  if (!missing(breaks_y) & plot_type == "single")
    warning("Argument 'breaks_y' does not need to be specified when plot_type is set to 'multiple'")
  if (missing(breaks_y)) breaks_y <- 1
  choice <- diagnostics(x, y)
  iter <- match(choice, attributes(x)$col_names)
  if (is.null(iter)) stop("Plotting is only for the series that reject the Null Hypothesis")
  if (length(choice) == 1 & plot_type == "multiple" )
    warning("Argument 'plot_type' should be set to 'single' when there is only one series to plot")

  dating <- attributes(x)$date[-c(1:(attributes(x)$minw + 1 + attributes(x)$lag))]
  shade.temp <- datestamp(x, y, option = option)

  if (plot_type == "multiple") {

    dat <- vector("list", length(choice))
    for (i in iter) {
      if (option == "badf") {
        if (attributes(y)$method == "Monte Carlo") {
          dat[[i]] <- data.frame(dating = dating, tstat = x$bsadf[, i],
                       if (attributes(x)$lag == 0) cv = y$badf_cv[,2] else cv =  head(y$badf_cv[, 2], -(attributes(x)$lag), row.names = NULL))
        } else if (attributes(y)$method == "Wild Bootstrap") {
          dat[[i]] <- data.frame(dating = dating, tstat = x$bsadf[, i],
                       if (attributes(x)$lag == 0) cv = y$badf_cv[,2, i] else cv =  head(y$badf_cv[, 2, i], -(attributes(x)$lag), row.names = NULL))
      }else if (option == "bsadf") {
        if (attributes(y)$method == "Monte Carlo") {
          dat[[i]] <- data.frame(dating = dating, tstat = x$bsadf[, i],
                       if (attributes(x)$lag == 0) cv = y$bsadf_cv[,2] else  cv =  head(y$bsadf_cv[, 2], -(attributes(x)$lag), row.names = NULL))
        } else if (attributes(y)$method == "Wild Bootstrap") {
          dat[[i]] <- data.frame(dating = dating, tstat = x$bsadf[, i],
                       if (attributes(x)$lag == 0) cv = y$bsadf_cv[,2, i] else  cv =  head(y$bsadf_cv[, 2, i], -(attributes(x)$lag), row.names = NULL))
        }
      }
      }
    }

    h <- vector("list", length(choice))
    j <- 1
    for (i in iter)
      local({
        i <- i
        p <- ggplot(dat[[i]]) + geom_line(aes_string(x = "dating", y = "tstat"), size = 0.7, colour = "blue") +
          geom_line(aes_string(x = "dating", y = "cv"), colour = "red", size = 0.8, linetype = "dashed") +
          xlab("") + ylab("") + theme_bw() +
          theme(axis.line = element_line(colour = "black"), panel.grid.major = element_blank(),
                panel.grid.minor = element_blank(), panel.background = element_blank()) +
          ggtitle(attributes(x)$col_names[j]) +
          scale_y_continuous(breaks = seq(floor(min(dat[[i]]$tstat)), ceiling(max(dat[[i]]$tstat)), breaks_y)) +
          geom_rect(data = shade.temp[[j]][1:2], aes_string(xmin = "Peak", xmax = "Trough", ymin = -Inf, ymax = +Inf),
                    fill = 'grey', alpha = 0.25) +
          {if (class(attributes(x)$date) == "Date") scale_x_date(date_breaks = breaks_x, date_labels = format_plot) else
                      scale_x_continuous(breaks = seq(0, max(attributes(x)$date), breaks_x))}
        h[[j]] <<- p
        j <<- j + 1

      })
  }else if (plot_type == "single") {

    plot.dummy  <- dummy.plot(x, y, option = option) %>% as.data.frame() %>%  select(iter)

    shade.dummy <- shade(plot.dummy)

    start.dummy <- shade.dummy$b %>% as.data.frame() %>% set_colnames(attributes(x)$col_names[iter]) %>%
      gather(value = "start", na.rm = TRUE)

    end.dummy <- shade.dummy$e %>% as.data.frame() %>% set_colnames(attributes(x)$col_names[iter]) %>%
      gather(value = "end", na.rm = TRUE)

    total <- bind_cols(start.dummy, end.dummy) %>% select(- !! sym("key1")) %>%
      mutate("start_date" = dating[!! sym("start")], "end_date" = dating[!! sym("end")])


    h <- ggplot(total, aes_string(colour = "key")) +
    geom_segment(aes_string(x = "start_date", xend = "end_date", y = "key", yend = "key"), size = 7) +
    ylab("") + xlab("") + theme_bw() +
    theme(panel.grid.major.y = element_blank() ,legend.position = "none",
          plot.margin = margin(1,1,0,0,"cm"), axis.text.y = element_text(face = "bold",
                                                                         size = 8, hjust = 0))
    if (class(attributes(x)$date) == "Date") {
      h <- h + scale_x_date(date_breaks = breaks_x, date_labels = format_plot)
    }else{
      h <- h + scale_x_continuous(breaks = seq(0, max(attributes(x)$date), breaks_x))
    }
  }

  return(h)
}
