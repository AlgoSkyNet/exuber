#' Title
#'
#' @param x of class 'radf'.
#' @param y the output of mc_cv or wb_cv
#'
#' @export
summary.radf <- function(x, y){

  if (x$info$minw != y$info$minw) {
    stop("The critical values should have the same minumum window with the t-statistics!")
  }
  cat('\n',"---------------------------------------------",'\n',
      "H0:", "Unit root ",'\n',
      "H1:", "Explosive root",
      "\n----------------------------------------------\n",
      "Critical values are generated by:" , y$info$method,'\n',
      "Number of iterations:", y$info$iter,'\n',
      "Minimum window is set to:", x$info$minw,'\n',
      "Lag is set to:", x$info$lag,'\n',
      "---------------------------------------------")

  if (y$info$method == "Wild Bootstrap") {
    for (i in seq_along(x$info$names)) {
      df1 <- c(x$adf[i], y$adf_cv[i, ])
      df2 <- c(x$sadf[i], y$sadf_cv[i, ])
      df3 <- c(x$gsadf[i], y$gsadf_cv[i, ])
      df <- data.frame( rbind(df1,df2,df3), row.names = c("ADF","SADF","GSADF"))
      colnames(df) <- c("t-stat", "90%", "95%", "95%")
      cat('\n', x$info$names[i], '\n')
      print(df)
    }
  }else if (y$info$method == "Monte Carlo") {
    for (i in seq_along(x$info$names)) {
      df1 <- c(x$adf[i], y$adf_cv)
      df2 <- c(x$sadf[i], y$sadf_cv)
      df3 <- c(x$gsadf[i], y$gsadf_cv)
      df <- data.frame( rbind(df1,df2,df3), row.names = c("ADF","SADF","GSADF"))
      colnames(df) <- c("tstat", "90%", "95%", "95%")
      cat('\n', x$info$names[i], '\n')
      print(df)
    }
  }
}

#' Title
#'
#' @param x of class radf
#' @param y the output of wb_cv or mc_cv
#' @param echo printed if TRUE
#'
#' @return the series that pass the 0.95 statistical signifigance test
#' @export
#'
diagnostics <- function(x, y, echo = TRUE){

  nm <- x$info$names
  proceed <- NULL
  sig <- NULL

  for (i in seq_along(nm)) {
    if (y$info$method == "Monte Carlo") {
      if (x$gsadf[i] > y$gsadf_cv[1]) {
        if (x$gsadf[i] > y$gsadf_cv[2]) {
          if (x$gsadf[i] > y$gsadf_cv[3]) {
            proceed <- c(proceed, nm[i])
            sig <- append(sig, "99%")
          }else{
            proceed <- c(proceed, nm[i])
            sig <- append(sig, "95%")
          }
        }else{
          proceed <- c(proceed, nm[i])
          sig <- append(sig, "90%")
        }
      } else{
        sig <- append(sig, "Reject")
      }
    }else{
      if (x$gsadf[i] > y$gsadf_cv[i, 1]) {
        if (x$gsadf[i] > y$gsadf_cv[i, 2]) {
          if (x$gsadf[i] > y$gsadf_cv[i, 3]) {
            proceed <- c(proceed, nm[i])
            sig <- append(sig, "99%")
          }else{
            proceed <- c(proceed, nm[i])
            sig <- append(sig, "95%")
          }
        }else{
          proceed <- c(proceed, nm[i])
          sig <- append(sig, "90%%")
        }
      }else{
        sig <- append(sig, "Reject")
      }
    }
  }
    if (echo) {
      cat('\n',
          "Diagnostics:",
          "\n---------------------------------------------")
      for (i in seq_along(nm)) {
        cat("\n", "Series ", nm[i],":", sep = "")
        if (sig[i] == "Reject") {
          cat("\n", "Cannot reject H0!")
        }else{
          cat("\n","Rejects H0 for significance level", sig[i])
        }
      }
      if (is.null(proceed)) {
        cat("\n---------------------------------------------",
            "\nYou cannot proceed for date stamping!")
      }else{
        cat("\n---------------------------------------------",
            "\nProcced for date stampting and plotting for variable(s)", deparse(proceed))
      }
    }
  return(invisible(proceed))
}

#' @export
dummy.plot <- function(x, y, option){

  dummy.plot <- matrix(0, nrow = NROW(x$badf), ncol = length(x$info$names))

  for (i in seq_along(x$info$names)) {
    for (j in 1:(NROW(x$bsadf))) {
      if (option == "badf") {
        if (y$info$method == "Monte Carlo") {
          if (x$bsadf[j, i] > y$badf_cv[j, 2]) dummy.plot[j, i] = 1
        }else if (y$info$method == "Wild Bootstrap") {
          if (x$bsadf[j, i] > y$badf_cv[j, 2, i]) dummy.plot[j, i] = 1
        }
      }else if (option == "bsadf") {
        if (y$info$method == "Monte Carlo") {
          if (x$bsadf[j, i] > y$bsadf_cv[j, 2, i]) dummy.plot[j, i] = 1
        }else if (y$info$method == "Wild Bootstrap") {
          if (x$bsadf[j, i] > y$bsadf_cv[j, 2, i]) dummy.plot[j, i] = 1
        }
      }else{
        stop("Argument 'option' should be either 'badf' or 'bsadf' !")
      }
    }
  }
  return(dummy.plot)
}

#' @export
shade <- function(x){
  b <- matrix(0, 100, NCOL(x))
  e <- matrix(0, 100, NCOL(x))
  for (i in 1:NCOL(x)) {
    if (x[1, i] == 1) { #detect when series start with bubble
      b[,i] <- c(1, which(diff(x[, i]) == 1) + 1,
                 rep(NA, NROW(b) - length(which(diff(x[,i]) == 1)) - 1))
    }else{
      b[,i] <- c(which(diff(x[, i]) == 1) + 1,
                 rep(NA, NROW(b) - length(which(diff(x[,i]) == 1))))
    }

    if (x[NROW(x),i]) {
      e[,i] <- c( which(diff(x[, i]) == -1) + 1, NROW(x),
                  rep(NA, NROW(e) - length(which(diff(x[,i]) == -1)) - 1))
    }else{
      e[,i] <- c( which(diff(x[, i]) == -1) + 1,
                  rep(NA, NROW(e) - length(which(diff(x[, i]) == -1))))
    }
  }
  return( list(b = b, e = e))
}


#' Title
#'
#' @param x of class radf
#' @param y the output of mc_cv or wb_cv
#' @param option c("bsadf", "badf") the default value is "bsadf"
#'
#' @return the periods the contain a bubble
#'
#' @import tidyr
#' @export
#'
date.stamp <- function(x, y, option = "badf"){

  dating <- x$info$date[-c(1:(x$info$minw + 1 + x$info$lag))]
  temp1 <- dummy.plot(x, y, option = option)
  temp2 <- shade(temp1)

  choice <- diagnostics(x, y, echo = FALSE)
  iter <- match(choice, x$info$names)
  rect.regions <- list()
  j <- 1
  for (i in iter) {
    temp3 <- data.frame(dating[temp2$b[, i]],
                        dating[temp2$e[, i]],
                        temp2$e[, i] - temp2$b[, i]) %>% drop_na()
    colnames(temp3) <- c("Peak", "Trough","Duration")
    rect.regions[[j]] <- temp3
    j <- j + 1
  }
  names(rect.regions) <- x$info$names[iter]
  return(rect.regions)
}

#' Plotting
#'
#' @param x of class radf
#' @param y the output of wb_cv or mc_cv
#' @param option c("bsadf", "badf")
#' @param breaks_x plotting option
#' @param format plotiing option
#' @param breaks_y plotting option
#' @param plot.type type gannt if true
#'
#' @return a list of ggplot
#' @export
#'
#' @import ggplot2
#' @import dplyr
#' @import tidyr
#'
plot.radf <- function(x, y,
                      option = "badf",
                      breaks_x,
                      format = "%m-%Y",
                      breaks_y = 1,
                      plot.type = "single") {

  if (missing(breaks_x)) {
    if (class(x$info$date) == "Date") {
      breaks_x = "3 months"
    }else{
      breaks_x = 1
    }
  }

  if (!missing(breaks_y) & plot.type == "multiple") {
    warning("'breaks_y' does not need to be specified when plot.type is 'multiple'")
  }

  choice <- diagnostics(x, y, echo = FALSE)
  iter <- match(choice, x$info$names)
  if (is.null(iter)) stop("Plotting is only for the series that reject the Null Hypothesis")

  dating <- x$info$date[-c(1:(x$info$minw + 1 + x$info$lag))]
  shade.temp <- date.stamp(x, y, option = option)

  if (plot.type == "single") {
    dat <- vector("list", length(choice))
    for (i in iter) {
      if (option == "badf") {
        if (y$info$method == "Monte Carlo") {
          dat[[i]] <- data.frame(dating = dating, tstat = x$bsadf[, i],
                                 cv =  head(y$badf_cv[, 2], -(x$info$lag), row.names = NULL))
        } else if (y$info$method == "Wild Bootstrap") {
          dat[[i]] <- data.frame(dating = dating, tstat = x$bsadf[, i],
                                 cv =  head(y$badf_cv[, 2, i], -(x$info$lag), row.names = NULL))
        }
      }else if (option == "bsadf") {
        if (y$info$method == "Monte Carlo") {
          dat[[i]] <- data.frame(dating = dating, tstat = x$bsadf[, i],
                                 cv =  head(y$bsadf_cv[, 2], -(x$info$lag), row.names = NULL))
        } else if (y$info$method == "Wild Bootstrap") {
          dat[[i]] <- data.frame(dating = dating, tstat = x$bsadf[, i],
                                 cv =  head(y$bsadf_cv[, 2, i], -(x$info$lag), row.names = NULL))
        }
      }else{
        stop("Argument 'option' should be either 'badf' or 'bsadf' !")
      }
   }
    h <- vector("list", length(choice))
    j <- 1
    for (i in iter)
      local({
        i <- i
        p <- ggplot(dat[[i]]) + geom_line(aes(x = dating, y = tstat), size = 0.7, colour = "blue") +
          geom_line(aes(x = dating, y = cv), colour = "red", size = 0.8, linetype = "dashed") +
          xlab("") + ylab("") + theme_bw() +
          theme(axis.line = element_line(colour = "black"), panel.grid.major = element_blank(),
                panel.grid.minor = element_blank(), panel.background = element_blank()) +
          scale_y_continuous(breaks = seq(floor(min(dat[[i]]$tstat)), ceiling(max(dat[[i]]$tstat)), breaks_y)) +
          geom_rect(data = shade.temp[[j]][1:2], aes(xmin = Peak, xmax = Trough, ymin = -Inf, ymax = +Inf),
                    fill = 'grey', alpha = 0.25)
          {if (class(x$info$date) == "Date") scale_x_date(date_breaks = breaks_x, date_labels = format) else
                      scale_x_continuous(breaks = seq(0, max(x$info$date), breaks_x))}
        h[[j]] <<- p + opts(tittle = i)
        j <<- j + 1

      })
  }else if (plot.type == "multiple") {

    plot.dummy.wout  <- dummy.plot(x, y, option = option)
    plot.dummy <- plot.dummy.wout[, iter, drop = FALSE]
    shade.dummy <- shade(plot.dummy)
    start.dummy <- shade.dummy$b
    end.dummy <- shade.dummy$e

    colnames(start.dummy) <- colnames(end.dummy) <- x$info$names[iter]

    g1 <- start.dummy %>% as.data.frame() %>% gather() %>% drop_na()
    g2 <- end.dummy %>% as.data.frame() %>% gather() %>% drop_na()

    g <- bind_cols(g1, g2[2])
    total <- bind_cols(key = g$key, start = dating[g$value], end = dating[g$value1]) %>% arrange(start)

    h <- ggplot(total, aes(colour = key)) +
    geom_segment(aes(x = start, xend = end, y = key, yend = key), size = 7) +
    ylab("") + xlab("") + theme_bw() +
    theme(panel.grid.major.y = element_blank() ,legend.position = "none",
          plot.margin = margin(1,1,0,0,"cm"), axis.text.y = element_text(face = "bold", size = 8, hjust = 0))
    if (class(x$info$date) == "Date") {
      h <- h + scale_x_date(date_breaks = breaks_x, date_labels = format)
    }else{
      h <- h + scale_x_continuous(breaks = seq(0, max(x$info$date), breaks_x))
    }
  }else{
    stop("'plot.type' should take the value 'single' or 'multiple'")
  }
  return(h)
}
